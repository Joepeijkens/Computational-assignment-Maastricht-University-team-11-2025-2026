install.packages("tidyverse")
install.packages("lubridate")

library(tidyverse)
library(lubridate)

#parameters to test the code
days <- 100
length_slot1 <- 0.5
length_slot2 <- 0.75
begin_day <- 8.0
end_day <- 17.0
hours_day <- end_day - begin_day

#for this we need the statistic analysis
arrival_rate_patient1 <- 12
arrival_rate_patient2 <- 8
duration_patient1_mean <- 0.45
duration_patient2_mean <- 0.65
duration_patient1_sd <- 0.1
duration_patient2_sd <- 0.2

set.seed(42)

#simulation for patients calling
call_simulation <- function(type, lambda, days){
  
  #number of patients is poisson distributed
  n_patients <- rpois(1, lambda * days)
  
  #simulation for when patients call
  #creates for eacht patient a fraction, later rounded down, which represents the day on which they call
  call_day_frac <- runif(n_patients, 1, days+1)
  call_day <- floor(call_day_frac)
  call_hour <- (call_day_frac - call_day)*9+8 #converts the fraction of the day to the hour of calling between 8.00 and 17.00
  
  #create an overview of when patients called
  tibble(
    PatientID = paste0(type, "_", 1:n_patients),
    Patient_type = type,
    Day_called = call_day,
    Hour_called = call_hour
  )
}

#runs simulation twice, for both types
arrivals_patient1 <- call_simulation("Type1", arrival_rate_patient1, days)
arrivals_patient2 <- call_simulation("Type2", arrival_rate_patient2, days)

#creates one big table with all patients ordered chronological
total_arrivals <- bind_rows(arrivals_patient1, arrivals_patient2)%>%
  arrange(Day_called, Hour_called)

#in this part we schedule the patients
schedule <- function(arrivals, length_slot, MRI){
  
  #this vector keeps track of how much of the day is already used by booked appointments
  current_used <- rep(0, days + 100) #we allow for a backlog to be scheduled after the days that we initially run the simulation
  
  #stores the schedule for all patients
  result <- vector("list", nrow(arrivals))
  
  #sets the first possible day that each patient can be scheduled the day after the patient called
  for(i in seq_len(nrow(arrivals))){
    patient <- arrivals[i, ]
    next_day <- patient$Day_called +1
    
    #checks if we can schedule a patient on the day after calling without exceeding 17.00, otherwise it moves to the day after that
    repeat{
      if((current_used[next_day] + length_slot) <= hours_day){
        
        start <- begin_day + current_used[next_day]
        current_used[next_day] <- current_used[next_day] + length_slot
        
        result[[i]]<- tibble(
          PatientID = patient$PatientID,
          #CHANGED FROM patient$Type TO patient$Patient_type TO MATCH ARRIVALS TABLE
          Patient_type = patient$Patient_type,
          Day_called = patient$Day_called,
          Day_treatment = next_day,
          Start_time_treatment = start,
          End_time_treatment = start + length_slot,
          Length_Slot = length_slot,
          MRI = MRI
        )
        break
        
      }
      else{
        next_day <- next_day +1
      }
    }
  }
  bind_rows(result)
}

MRI1_schedule <- schedule(arrivals_patient1, length_slot1, "MRI1")
MRI2_schedule <- schedule(arrivals_patient2, length_slot2, "MRI2")

#chronological table of scheduled patients on both MRI's
complete_schedule <- bind_rows(MRI1_schedule, MRI2_schedule)%>%
  arrange(MRI, Day_treatment, Start_time_treatment)

#create the durations of eacht patient from the normal distribution
#CHANGE - SHOULD BE complete_schedule I THINK
data <- complete_schedule %>%
  mutate(
    duration = case_when(
      Patient_type == "Type1" ~ rnorm(n(), duration_patient1_mean, duration_patient1_sd),
      Patient_type == "Type2" ~ rnorm(n(), duration_patient2_mean, duration_patient2_sd)
    ),
    #set a lowerbound for the duration since we do not allow the duration to be negative or zero
    duration = pmax(0.1, duration)
  )

# ADDED PART FOR KPIs
#sort by MRI and time to ensure we process the queue in order
data <- data_prelim %>% 
  arrange(MRI, Day_treatment, Start_time_treatment)

#initialize columns for actual start and end times
data$Actual_start_time <- data$Start_time_treatment
data$Actual_end_time <- 0 

#loop through every patient to update times based on the previous patient's finish time
for(i in 1:nrow(data)) {
  # check if it is the first patient of the dataset OR a new machine OR a new day (in these cases, the patient starts exactly on their scheduled time)
  if(i == 1 || data$MRI[i] != data$MRI[i-1] || data$Day_treatment[i] != data$Day_treatment[i-1]) {
    data$Actual_start_time[i] <- data$Start_time_treatment[i]
  } else {
    # otherwise, they start at the LATER of: A) their scheduled time or B) when the previous patient actually finished (the ripple effect)
    data$Actual_start_time[i] <- max(data$Start_time_treatment[i], data$Actual_end_time[i-1])
  }
  
  #calculate their actual finish time based on the actual start + random duration
  data$Actual_End_Time[i] <- data$Actual_start_time[i] + data$duration[i]
}

#calculate final performance metrics
final_data <- data %>%
  mutate(
    #calculate waiting room delay (difference between actual start and scheduled start)
    Waiting_room_delay = Actual_start_time - Start_time_treatment,
    #check for overtime (did they finish after 17.00?)
    Is_overtime = Actual_end_time > 17.0,
    #calculate how many hours of overtime occurred
    Overtime_amount = pmax(0, Actual_end_time - 17.0),
    #the number of days the patient waited for the appointment
    Access_time_days = Day_treatment - Day_called
  )

#calculate daily stats
daily_performance <- final_data %>%
  group_by(MRI, Day_treatment) %>%
  summarise(
    Total_work_hours = sum(duration),
    Last_patient_finish = max(Actual_end_time),
    Daily_overtime = pmax(0, Last_Patient_Finish - 17.0),
    .groups = "drop"
  )
