install.packages("tidyverse")
install.packages("lubridate")

library(tidyverse)
library(lubridate)

#parameters to test the code
days <- 100
length_slot1 <- 0.5
length_slot2 <- 0.75
begin_day <- 8.0
end_day <- 17.0
hours_day <- end_day - begin_day

#for this we need the statistic analysis
arrival_rate_patient1 <- 12
arrival_rate_patient2 <- 8
duration_patient1_mean <- 0.45
duration_patient2_mean <- 0.65
duration_patient1_sd <- 0.1
duration_patient2_sd <- 0.2

set.seed(42)

#simulation for patients calling
call_simulation <- function(type, lambda, days){
  
  #number of patients is poisson distributed
  n_patients <- rpois(1, lambda * days)
  
  #simulation for when patients call
  call_day_frac <- runif(n_patients, 1, days+1)
  call_day <- floor(call_day_frac)
  call_hour <- (call_day_frac - call_day)*9+8 
  
  tibble(
    PatientID = paste0(type, "_", 1:n_patients),
    Patient_type = type,
    Day_called = call_day,
    Hour_called = call_hour
  )
}

#runs simulation twice, for both types
arrivals_patient1 <- call_simulation("Type1", arrival_rate_patient1, days)
arrivals_patient2 <- call_simulation("Type2", arrival_rate_patient2, days)

#NEW: For the pooled model, we combine EVERYONE into one queue immediately
#processed first-come-first-served based on when they called
total_arrivals_pooled <- bind_rows(arrivals_patient1, arrivals_patient2) %>%
  arrange(Day_called, Hour_called)

#NEW: Pooled Scheduling Function
schedule_pooled <- function(arrivals, slot1, slot2){
  
  #implement two trackers, one for each machine
  current_used_mri1 <- rep(0, days + 100)
  current_used_mri2 <- rep(0, days + 100)
  
  result <- vector("list", nrow(arrivals))
  
  for(i in seq_len(nrow(arrivals))){
    patient <- arrivals[i, ]
    
    #determine how long this specific patient takes
    # (Type 1 is always 0.5, Type 2 is always 0.75, regardless of machine)
    needed_slot <- if(patient$Patient_type == "Type1") slot1 else slot2
    
    #helper function to find the earliest slot on a specific machine tracker
    find_earliest_slot <- function(tracker, start_search_day, duration) {
      check_day <- start_search_day
      repeat {
        if((tracker[check_day] + duration) <= hours_day) {
          return(list(day = check_day, start_time = begin_day + tracker[check_day]))
        }
        check_day <- check_day + 1
      }
    }
    
    #best option on MRI 1
    option1 <- find_earliest_slot(current_used_mri1, patient$Day_called + 1, needed_slot)
    #best option on MRI 2
    option2 <- find_earliest_slot(current_used_mri2, patient$Day_called + 1, needed_slot)
    
    #compare and pick the winner (We prefer the earliest day. If days are equal, we prefer the earliest time.)
    use_MRI1 <- FALSE
    
    if (option1$day < option2$day) {
      use_MRI1 <- TRUE
    } else if (option1$day == option2$day && option1$start_time <= option2$start_time) {
      use_MRI1 <- TRUE
    } else {
      use_MRI1 <- FALSE
    }
    
    #book the appointment
    if(use_MRI1) {
      chosen_MRI <- "MRI1"
      chosen_day <- option1$day
      chosen_start <- option1$start_time
      #update MRI 1 tracker
      current_used_mri1[chosen_day] <- current_used_mri1[chosen_day] + needed_slot
    } else {
      chosen_MRI <- "MRI2"
      chosen_day <- option2$day
      chosen_start <- option2$start_time
      #update MRI 2 tracker
      current_used_mri2[chosen_day] <- current_used_mri2[chosen_day] + needed_slot
    }
    
    result[[i]] <- tibble(
      PatientID = patient$PatientID,
      Patient_type = patient$Patient_type,
      Day_called = patient$Day_called,
      Day_treatment = chosen_day,
      Start_time_treatment = chosen_start,
      End_time_treatment = chosen_start + needed_slot,
      Length_Slot = needed_slot,
      MRI = chosen_MRI
    )
  }
  bind_rows(result)
}

#run the pooled schedule
complete_schedule_pooled <- schedule_pooled(total_arrivals_pooled, length_slot1, length_slot2)

#this part is almost identical to the previous model because once scheduled, the machines operate independently.
final_data_pooled <- complete_schedule_pooled %>%
  arrange(MRI, Day_treatment, Start_time_treatment) %>%
  group_by(MRI, Day_treatment) %>%
  mutate(
    # Generate random durations
    duration = case_when(
      Patient_type == "Type1" ~ rnorm(n(), duration_patient1_mean, duration_patient1_sd),
      Patient_type == "Type2" ~ rnorm(n(), duration_patient2_mean, duration_patient2_sd)
    ),
    duration = pmax(0.1, duration),

#loop through row by row to carry delays forward
for(i in 1:nrow(data)) {
  
  #check if this is a "Reset" point.
  # It is a reset if: 1. It's the very first row, 2. It's a different MRI machine than the row before or 3. It's a different day than the row before
  if(i == 1 || data$MRI[i] != data$MRI[i-1] || data$Day_treatment[i] != data$Day_treatment[i-1]) {
    
    #no delay carry-over: They start exactly at their scheduled time
    data$Actual_start_time[i] <- data$Start_time_treatment[i]
  } else {
    # The ripple effect: They start at the LATER of: A) Their scheduled time (if the previous patient finished early) or B) The previous patient's finish time (if the previous patient ran late)
    data$Actual_start_time[i] <- max(data$Start_time_treatment[i], data$Actual_end_time[i-1])
  }
  
  #calculate finish time based on the determined start time + actual duration
  data$Actual_end_time[i] <- data$Actual_start_time[i] + data$duration[i]
}

#calculate final perfomance metrics
final_data <- data %>%
  mutate(
    #calculate waiting room delay (difference between actual start and scheduled start)
    Waiting_room_delay = Actual_start_time - Start_time_treatment,
    #check for overtime (did they finish after 17.00?)
    Is_overtime = Actual_end_time > 17.0,
    #calculate how many hours of overtime occurred
    Overtime_amount = pmax(0, Actual_end_time - 17.0),
    #number of days the patient waited for the appointment
    Access_time_days = Day_treatment - Day_called
  )

#calculate daily stats
daily_performance <- final_data %>%
  group_by(MRI, Day_treatment) %>% 
  summarise(
    Total_work_hours = sum(duration),
    Last_patient_finish = max(Actual_end_time),
    Daily_overtime = pmax(0, Last_patient_finish - 17.0), 
    .groups = "drop"
  )
